\documentclass[xcolor={dvipsnames}]{beamer}

\usetheme{metropolis}

\usepackage{graphicx}
\usepackage{listings}

\author{Joel Berkeley}
\title{Functional Programming}
\institute{Verimatrix Bristol}
\date{October 2017}

\setbeamercolor*{structure}{
  bg=OliveGreen!20,
  fg=OliveGreen
}
\setbeamercolor*{palette primary}{
  use=structure,
  fg=OliveGreen,
  bg=structure.fg
}
\setbeamercolor{section in toc}{
  fg=black,
  bg=white
}
\setbeamercolor{alerted text}{
  use=structure,
  fg=structure.fg!50!black!80!black
}
\setbeamercolor{titlelike}{
  parent=palette primary,
  fg=structure.fg!50!black
}
\setbeamercolor{frametitle}{
  bg=gray!10!white,
  fg=OliveGreen
}
\setbeamercolor*{titlelike}{
  parent=palette primary
}

\lstset{
	language=Scala,
	keywordstyle=\color{OliveGreen}\textbf,
	stringstyle=\color{OliveGreen},
  commentstyle=\color{gray},
  showstringspaces=false
}

\begin{document}

\begin{frame}
  \maketitle
\end{frame}

\begin{frame}
  \frametitle{(Some) programming paradigms}
  \begin{itemize}
    \item<1-> \textbf{Imperative} \ldots statements directly change current state
    \item<2-> \textbf{Procedural} \ldots functions as subroutines
    \item<3-> \textbf{Object-oriented} \ldots data as objects with predefined methods
    \item<4-> \textbf{Automata-based} \ldots e.g. FSM
    \item<5-> \textbf{Functional} \ldots computation through evaluation of mathematical functions
  \end{itemize}
\end{frame}

\section{Functional programming}

\begin{frame}
  \frametitle{Overview}
  \begin{itemize}
  	\item<1-> pure functions (in mathematical sense)
  	\begin{itemize}
  	  \item<2-> referential transparency
     	\item<2-> pattern matching
      \item<2-> recursion
  	\end{itemize}
  	\item<3-> first-class functions
    \item<4-> higher-order functions
    \item<5-> can be object-oriented
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Languages}
  \begin{itemize}
    \item Haskell
    \item Scala
    \item Clojure
    \item Elixir
    \item R
    \item \ldots others
  \end{itemize}
\end{frame}

\section{And in greater detail \ldots}

\begin{frame}
  \frametitle{Pure functions}
  Aspects \ldots
  \begin{itemize}
    \item<2-> referentially transparent \lstinputlisting[firstline=2, lastline=3, showstringspaces=false]{scala/src/main/scala/ReferentialTransparency.scala}
    \item<3-> explicit \& controlled \ldots
      \begin{itemize}
        \item side effects
        \item access to external state (e.g. random numbers, time)
        \item I/O
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Pure functions}
  Consequences \ldots
  \begin{itemize}
    \item<2-> easier to
      \begin{itemize}
        \item follow code
        \item unit test
        \item refactor
      \end{itemize}
    \item<3-> thread-safe
    \item<4-> state must be handled differently, e.g.
      \begin{itemize}
        \item monads
        \item state-passing
      \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Recursion}
  \uncover<2->{
    Without recursion \ldots
    \lstinputlisting[firstline=2, lastline=6, showstringspaces=false]{scala/src/main/scala/NonRecursive.scala}
  }
  \uncover<3>{
    With recursion \ldots
    \lstinputlisting[firstline=2, lastline=5, showstringspaces=false]{scala/src/main/scala/Recursion.scala}
  }
\end{frame}

\begin{frame}
  \frametitle{Pattern matching}
  \lstinputlisting[firstline=2, lastline=11, showstringspaces=false]{scala/src/main/scala/PatternMatching.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{First class functions}
  Pass around functions like variables
  \lstinputlisting[firstline=2, lastline=6]{scala/src/main/scala/FirstClassFunctions.scala}
  notice that, ‘=’ is \textit{after} the function value declaration, unlike for a function.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Higher order functions}
  Take functions as arguments, or return functions e.g.
  \lstinputlisting[firstline=2, lastline=9]{scala/src/main/scala/HigherOrderFunctions.scala}
\end{frame}

\begin{frame}
  \frametitle{Functional OOP}
  \begin{itemize}
    \item immutable objects
    \item methods return new objects
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Functional objects vs. functional classes}
  \lstinputlisting[firstline=4, lastline=15]{scala/src/main/scala/FunctionalClassVSObject.scala}
\end{frame}

\section{Summary}

\begin{frame}
  \frametitle{Summary}
  Functional programming uses \ldots
  \begin{itemize}
  	\item<1-> pure functions
  	\begin{itemize}
  	  \item<2-> referential transparency
     	\item<2-> pattern matching
      \item<2-> recursion
  	\end{itemize}
  	\item<3-> first-class functions
    \item<4-> higher-order functions
    \item<5-> can be object-oriented
  \end{itemize}
\end{frame}

\end{document}
