\documentclass[xcolor={dvipsnames}]{beamer}

\usetheme{metropolis}

\usepackage{graphicx}
\usepackage{listings}

\author{Joel Berkeley}
\title{Functional Programming}
%\institute{}
\date{}

\setbeamercolor*{structure}{
  bg=OliveGreen!20,
  fg=OliveGreen
}
\setbeamercolor*{palette primary}{
  use=structure,
  fg=OliveGreen,
  bg=structure.fg
}
\setbeamercolor{section in toc}{
  fg=black,
  bg=white
}
\setbeamercolor{alerted text}{
  use=structure,
  fg=structure.fg!50!black!80!black
}
\setbeamercolor{titlelike}{
  parent=palette primary,
  fg=structure.fg!50!black
}
\setbeamercolor{frametitle}{
  bg=gray!10!white,
  fg=OliveGreen
}
\setbeamercolor*{titlelike}{
  parent=palette primary
}

\lstset{
	language=Scala,
	keywordstyle=\color{OliveGreen}\textbf,
	stringstyle=\color{OliveGreen},
  commentstyle=\color{gray},
  showstringspaces=false
}

\begin{document}

\begin{frame}
  \maketitle
\end{frame}

\begin{frame}
  \frametitle{Paradigms}
  \begin{itemize}
    \item<1-> \textbf{imperative} \ldots\ directly mutate current state
    \item<2-> \textbf{procedural} \ldots\ subroutines
    \item<3-> \textbf{functional} \ldots\ separate definition \& execution
  \end{itemize}
\end{frame}

\section{FP overview}

\begin{frame}[fragile]
  \frametitle{Intention}
  \only<1> {
    separate definition and execution \ldots\
  }
  \only<2-> {
    \begin{itemize}
      \item<2-> referential transparency \ldots\ expression $\leftrightarrow$ result \lstinputlisting[firstline=5, lastline=7, showstringspaces=false]{scala/src/main/scala/ReferentialTransparency.scala}
      \item<3-> manage side effects
        \begin{itemize}
          \item mutation
          \item errors
          \item I/O, external state (random numbers, time, \ldots)
        \end{itemize}
      \item<4-> employ category theory
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Consequences (vs Imperative)}
  \begin{itemize}
    \item<1-> composable $\therefore$ easier to
      \begin{itemize}
        \item follow code
        \item test
        \item refactor
      \end{itemize}
    \item<2-> thread-safe
    \item<3-> can impact performance
    \item<4-> handle state differently \ldots\ how?
  \end{itemize}
\end{frame}

\section{FP examples}

\begin{frame}[fragile]
  \frametitle{Handling state - recursion}
  \only<1> {
    \lstinputlisting[firstline=3, lastline=8, showstringspaces=false]{scala/src/main/scala/Recursion.scala}
  }
  \only<2> {
    \lstinputlisting[firstline=12, lastline=19, showstringspaces=false]{scala/src/main/scala/Recursion.scala}
  }
\end{frame}

\begin{frame}
  \frametitle{Handling state - errors}
  \textit{Return} error with result
  \lstinputlisting[firstline=4, lastline=9, showstringspaces=false]{scala/src/main/scala/Errors.scala}
\end{frame}

\section{FP constructs}

\begin{frame}
  \frametitle{Data structures}
  Immutable/persistent ADTs e.g.
  \lstinputlisting[firstline=5, lastline=8, showstringspaces=false]{scala/src/main/scala/ADT.scala}
\end{frame}

\begin{frame}
  \frametitle{Pattern matching}
  Traverse ADTs
  \lstinputlisting[firstline=10, lastline=13, showstringspaces=false]{scala/src/main/scala/ADT.scala}
\end{frame}

\begin{frame}
  \frametitle{First class \& higher order functions}
  \lstinputlisting[firstline=2, lastline=11]{scala/src/main/scala/FirstClassHOFunctions.scala}
\end{frame}

\begin{frame}
  \frametitle{Performance}
  FP interface, imperative implementation
  \lstinputlisting[firstline=2, lastline=9, showstringspaces=false]{scala/src/main/scala/Recursion.scala}
\end{frame}

\begin{frame}
  \frametitle{Laziness}
  \begin{itemize}
    \item<1-> separate definition \& execution \ldots\ of values
    \item<2-> evaluate when needed
    \item<3-> allowed by RT \ldots\ order of evaluation not important
    \item<4-> producer \& consumer
    \item<5-> improves modularity \& performance
  \end{itemize}
\end{frame}

\section{FP languages}

\begin{frame}[fragile]
  \frametitle{FP languages}
  \begin{itemize}
    \item \textbf{historical} \ldots\ IPL, APL, FP, NPL, K, Q, ML/dialects, Lisp/dialects
    \item \textbf{research} \ldots\ Miranda, Haskell, Julia
    \item \textbf{commercial} \ldots\ R, Clojure, Scala, F$^\sharp$, Elixir, Elm
    \item \textbf{FP-influenced} \ldots\ many
  \end{itemize}
\end{frame}

\section{Take-homes}

\begin{frame}
  Separate definition \& execution ...
  
  \hfill ... by passing state etc.
  
  \center{\ldots\ and get composability, testability and safety}
\end{frame}

\end{document}
